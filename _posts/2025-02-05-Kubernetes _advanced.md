---
title: Kubernetes 개념2
description: >
author: Jongkwan Lee
date: 2025-02-05 21:20 +0900
categories: [Kubernetes]
tags: [Kubernetes]
pin: false
math: true
---

## 1. 네트워킹 및 서비스

### 1) 서비스(Service) 개념 및 종류

**가. 서비스(Service)란?**  
- 쿠버네티스에서 *Service*는 여러 개의 Pod를 하나의 논리적 그룹으로 묶어서 네트워크 접근을 제공하는 추상 레이어입니다.  
- Pod는 필요에 따라 동적으로 스케일 아웃/인할 수 있으며, IP 주소나 포트 등이 자주 바뀔 수 있습니다. *Service*는 이러한 Pod 집합에 고정된 접근 지점을 제공함으로써, 클라이언트가 Pod의 동적 변화를 일일이 추적하지 않아도 되게 해줍니다.

**나. 서비스의 종류**  
1. **ClusterIP**  
   - 기본적인 서비스 타입이며, 클러스터 내부에서만 접근 가능한 IP(가상 IP)를 할당받습니다.  
   - 같은 클러스터 내의 다른 Pod나 서비스가 해당 IP로 접근할 수 있어, 클러스터 내부 통신에 가장 많이 사용됩니다.
2. **NodePort**  
   - ClusterIP에 추가로, *각 노드의 고정 포트*를 할당하여 클러스터 외부에서 접근할 수 있도록 합니다.  
   - NodePort를 통해 외부에서 `NodeIP:NodePort`로 접근하면, 내부적으로 클러스터IP 서비스로 트래픽이 라우팅됩니다.
3. **LoadBalancer**  
   - 주로 클라우드 환경(AWS, GCP, Azure 등)에서 사용되는 서비스 타입입니다.  
   - 외부 로드밸런서를 자동으로 생성해주어, 외부 트래픽을 NodePort 혹은 ClusterIP로 분배합니다.  
   - 클라우드 벤더가 제공하는 로드밸런서(ELB, LB 등) 리소스와 직접 연동됩니다.

### 2) Ingress

**가. Ingress 리소스**  
- *Ingress*는 HTTP/HTTPS 트래픽에 대한 라우팅 규칙을 정의하는 쿠버네티스 오브젝트입니다.  
- 외부에서 들어오는 HTTP(S) 요청을 어떻게 라우팅할지 도메인/경로 기반으로 설정할 수 있습니다.  
- 간단히 말해, URL 경로나 호스트명에 따라 내부 서비스로의 트래픽 분배를 가능하게 합니다.

**나. Ingress Controller**  
- Ingress 리소스는 *Ingress Controller*라는 별도의 컨트롤러를 통해 실제로 동작합니다.  
- 쿠버네티스 자체에 기본 Ingress Controller가 내장되어 있지는 않으며, 대표적으로 Nginx Ingress Controller, HAProxy, Traefik, Istio Gateway 등이 사용됩니다.  
- Ingress Controller가 Ingress 리소스를 모니터링하면서 설정을 동적으로 반영하고, 외부 트래픽을 적절히 라우팅합니다.

### 3) 네임스페이스(Namespace) 및 네트워크 정책(NetworkPolicy)

**가. 네임스페이스(Namespace)**  
- 네임스페이스는 하나의 쿠버네티스 클러스터를 논리적으로 여러 구역으로 나누어 리소스를 격리/관리하는 방법입니다.  
- 예: `default`, `kube-system`, `kube-public` 등의 기본 네임스페이스가 있으며, 필요한 경우 별도의 네임스페이스를 생성해 프로젝트 단위 혹은 팀 단위로 리소스를 격리할 수 있습니다.  
- 자원 이름 충돌 방지, 자원 할당(리소스 쿼터) 등 관리 측면에서도 유용합니다.

**나. 네트워크 정책(NetworkPolicy)**  
- 네트워크 정책은 *Pod 간 혹은 Pod과 외부 간의 트래픽 흐름을 제어*합니다.  
- 기본적으로 쿠버네티스 Pod는 같은 네임스페이스 내에서 서로 자유롭게 통신할 수 있지만, NetworkPolicy를 사용해 특정 Label을 가진 Pod만 통신하도록 제한하거나, 특정 포트로의 접근을 막는 등의 세분화된 정책을 적용할 수 있습니다.  
- 네트워크 보안 강화나 멀티테넌시 환경에서 중요한 역할을 합니다.


## 2. 스토리지 및 구성 관리

### 1) 스토리지 개념

**가. 컨테이너와 스토리지**  
- 기본적으로 컨테이너는 임시 파일시스템을 사용하기 때문에, 컨테이너 재시작 시 데이터가 사라집니다.  
- 쿠버네티스는 이를 해결하기 위해 *Volume* 개념과 *PersistentVolume*을 제공합니다.

### 2) Volume, PersistentVolume(PV), PersistentVolumeClaim(PVC)

1. **Volume**  
   - Pod 내부에서 마운트되어 사용하는 디렉터리를 의미합니다.  
   - *emptyDir*, *hostPath*, *configMap*, *secret* 등 다양한 볼륨 타입이 존재합니다.  
   - Pod 생명주기와 밀접하게 연관되어, Pod가 삭제되면 데이터도 사라질 수 있습니다(볼륨 타입에 따라 다름).

2. **PersistentVolume(PV)**  
   - 실제 물리적/논리적 스토리지(클라우드 스토리지, NFS 등)를 추상화한 쿠버네티스 리소스입니다.  
   - 클러스터 내에서 영구적으로 사용할 수 있는 스토리지 공간으로, 동적으로 혹은 정적으로 미리 할당할 수 있습니다.

3. **PersistentVolumeClaim(PVC)**  
   - Pod가 필요로 하는 스토리지 요구사항(크기, 접근 모드 등)을 선언하는 리소스입니다.  
   - PVC가 생성되면, 쿠버네티스는 해당 요구사항을 만족하는 PV를 바인딩하여 Pod에 연결해줍니다.  
   - 이를 통해 Pod는 영구적인 스토리지(PV)를 사용할 수 있게 됩니다.

### 3) 환경설정 관리(ConfigMap & Secret)

**가. ConfigMap**  
- 애플리케이션의 환경 설정(예: 설정 파일, 환경 변수 등)을 저장하고 관리하기 위한 리소스입니다.  
- 일반 텍스트 형태(기밀이 아닌 데이터)를 저장하고, 필요 시 Pod에서 마운트하거나 환경 변수로 주입할 수 있습니다.  
- 애플리케이션 코드와 설정이 분리되어, 운영 환경에 따라 다른 설정을 유연하게 적용할 수 있습니다.

**나. Secret**  
- 기밀 정보(비밀번호, API 토큰, 인증서 키 등)를 안전하게 저장하기 위한 쿠버네티스 리소스입니다.  
- Base64 인코딩을 사용하지만, 기본적으로 쿠버네티스에서 etcd를 암호화하지 않을 경우 완벽한 보안이 아니라는 점에 유의해야 합니다.  
- 관리, 마운트 방식은 ConfigMap과 유사하지만, 보안이 필요한 민감 정보라는 점에서 활용처가 다릅니다.


## 3. 애플리케이션 배포 및 관리

### 1) 배포 전략

**가. 롤링 업데이트(Rolling Update)**  
- 신규 버전의 Pod를 점진적으로 생성하고, 구 버전의 Pod를 하나씩 제거하여 순차적으로 배포합니다.  
- 서비스 다운타임을 최소화하면서, 점진적으로 모든 Pod를 최신 버전으로 교체합니다.  
- 디플로이먼트(Deployment) 리소스가 제공하는 기본 전략이며, 파라미터를 조정해 *maxSurge*, *maxUnavailable* 등을 통해 무중단 배포가 가능합니다.

**나. 롤백(Rollback)**  
- 배포에 문제가 생길 경우, 이전 버전으로 신속히 되돌리는 것을 의미합니다.  
- 디플로이먼트 히스토리를 쿠버네티스가 저장하고 있으므로, `kubectl rollout undo` 명령 등으로 이전 상태로 복원할 수 있습니다.

### 2) 캐나리(Canary), 블루/그린(Blue/Green) 배포 패턴

1. **Canary 배포**  
   - 새 버전의 애플리케이션을 일부 트래픽에만 노출하여(예: 5~10%), 문제 발생 여부를 모니터링 후 점진적으로 트래픽을 늘리는 전략입니다.  
   - 트래픽 라우팅을 세분화해 리스크를 줄이고, 안정성이 확인되면 전체로 배포 범위를 확대합니다.

2. **Blue/Green 배포**  
   - *두 개의 동일한 프로덕션 환경(Blue, Green)을 운영*하고, 새 버전은 유휴 환경(예: Green)에 배포합니다.  
   - 충분히 테스트를 거친 뒤, 트래픽 스위치를 한 번에 전환하여 빠르게 새 버전을 활성화합니다.  
   - 롤백 시에는 이전 환경(Blue)로 쉽게 전환 가능하다는 장점이 있으나, 비용이 더 들 수 있습니다(두 환경을 모두 유지).

### 3) 상태 저장 애플리케이션 관리

**가. StatefulSet**  
- 쿠버네티스에서 데이터베이스, 캐시 서버 등 *상태를 가지는 애플리케이션*을 배포하기 위한 컨트롤러입니다.  
- Pod에 고유한 ID(이름, 네트워크 ID, 스토리지)를 부여하여, 재시작/스케일링 시에도 Pod 순서나 네트워크 정체성 등을 보장해줍니다.  
- 각 Pod에 대해 고유한 스토리지(PVC)를 연결해, 데이터 무결성을 유지할 수 있습니다.

**나. 데이터베이스 배포 시 주의사항**  
- StatefulSet으로 DB를 배포할 경우, PV/PVC 사용으로 영구 스토리지를 보장해야 합니다.  
- Pod 교체나 스케일링 시에도 데이터 유실을 방지할 수 있도록 스토리지 클래스를 잘 구성해야 합니다.  
- 노드 장애 대비 백업/복구 전략 등도 함께 고려해야 합니다.


## 4. 보안 및 접근 제어

### 1) RBAC (Role Based Access Control)

**가. RBAC 개념**  
- RBAC는 사용자(주체)에게 특정 동작(리소스 읽기/쓰기에 대한 권한 등)을 부여하거나 제한하기 위해 사용되는 쿠버네티스 접근 제어 메커니즘입니다.  
- 크게 *Role/ClusterRole*, *RoleBinding/ClusterRoleBinding*을 사용합니다.

**나. 역할(Roles) 및 역할 바인딩(Role Bindings)**  
1. **Role**  
   - 특정 네임스페이스 내에서 동작하는 권한을 정의합니다(리소스: `pods`, `services`, `deployments`, 동작: `get`, `list`, `create` 등).  
   - 예: `Role`을 사용해 `dev-namespace` 안에서만 배포(Deployment) 생성 및 삭제 권한을 부여할 수 있습니다.
2. **ClusterRole**  
   - 클러스터 전역에서 동작하는 권한을 정의합니다.  
   - 네임스페이스 구분 없이 특정 리소스에 대한 권한을 부여하거나, 네임스페이스 리스트 조회 등 클러스터 레벨의 권한이 필요한 경우 사용됩니다.
3. **RoleBinding / ClusterRoleBinding**  
   - 특정 사용자나 서비스 어카운트(ServiceAccount)에 위에서 정의한 Role 또는 ClusterRole을 연결해주는 리소스입니다.  
   - RoleBinding은 한 네임스페이스 내에서만 유효하고, ClusterRoleBinding은 클러스터 전체에 적용됩니다.

### 2) Pod 보안 정책(Pod Security Policy) 및 Security Context

> **주의**: *PodSecurityPolicy*는 쿠버네티스 1.25 버전부터 *Deprecated* 되었습니다. 최신 버전에서는 *Pod Security Admission* 기능으로 대체됩니다.

1. **Pod Security Policy(PSP)**  
   - Pod가 런타임 시 어떤 보안 조건을 만족해야 하는지 정의합니다(특정 사용자/그룹, SELinux 컨텍스트, 볼륨 타입 제한 등).  
   - 호스트 네트워크, 호스트 PID 접근, 권한 상승 등 민감한 권한을 제한할 수 있습니다.  
   - 점차 Pod Security Admission 정책으로 전환 중입니다.

2. **Security Context**  
   - Pod 또는 컨테이너 수준에서 실행 사용자(runAsUser), 그룹(runAsGroup), 권한 상승 여부(allowPrivilegeEscalation) 등을 설정합니다.  
   - 공격 표면을 줄이고 최소 권한 원칙을 적용하기 위해 사용됩니다.

### 3) 네트워크 보안 정책(NetworkPolicy)을 통한 트래픽 제어

- 이미 1에서 언급했듯이, NetworkPolicy는 Pod 간 혹은 Pod과 외부 간 트래픽을 세밀하게 제어할 수 있는 리소스입니다.  
- **Ingress**(들어오는 트래픽), **Egress**(나가는 트래픽)를 각각 혹은 동시에 제어하며, 라벨 셀렉터 기반으로 특정 Pod만 허용/차단이 가능합니다.  
- 멀티 테넌트 환경이나 민감한 데이터 트래픽을 분리하고 싶을 때 필수적으로 사용됩니다.
