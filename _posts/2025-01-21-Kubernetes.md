---
title: Kubernetes 개념
description: >
author: Jongkwan Lee
date: 2025-02-04 21:10 +0900
categories: [Kubernetes]
tags: [Kubernetes]
pin: false
math: true
---

## 1. 컨테이너화 및 컨테이너 오케스트레이션 개념

### 컨테이너화

- **개념:**  
  애플리케이션과 그 의존성을 하나의 이미지로 패키징하여, 실행 환경과 상관없이 일관되게 작동하도록 하는 기술입니다.
- **세부 설명:**
  - **이식성:** 컨테이너 이미지에는 애플리케이션 코드, 라이브러리, 설정 파일 등이 모두 포함되므로, 개발 환경, 테스트 환경, 프로덕션 환경 간의 차이로 인한 문제를 최소화할 수 있습니다.
  - **격리성:** 각각의 컨테이너는 독립적인 실행 환경을 제공하여, 다른 애플리케이션이나 서비스와의 간섭 없이 동작합니다.
  - **경량성:** 전통적인 가상 머신에 비해 운영체제의 전체 복제 없이 필요한 부분만 격리하기 때문에 자원 소모가 적고, 빠르게 시작 및 종료할 수 있습니다.

### 컨테이너 오케스트레이션의 개념

- **개념:**  
  단일 컨테이너가 아니라 여러 컨테이너들을 자동으로 배포, 관리, 확장, 업데이트 및 모니터링하는 기술을 의미합니다.
- **세부 설명:**
  - **자동화:** 수십에서 수백 개에 이르는 컨테이너를 사람이 일일이 관리하기에는 복잡하고 오류가 발생하기 쉽습니다. 오케스트레이션 도구는 이러한 반복적인 작업을 자동화하여 운영 효율성을 크게 향상시킵니다.
  - **자동 스케일링:** 시스템 부하나 트래픽 변화에 따라 컨테이너의 수를 자동으로 늘리거나 줄여 자원을 효율적으로 활용합니다.
  - **롤링 업데이트와 롤백:** 애플리케이션을 업데이트할 때 한 번에 전체 시스템을 변경하지 않고, 단계별로 업데이트를 진행한 후 문제가 발생하면 이전 버전으로 빠르게 롤백할 수 있습니다.
  - **셀프-힐링:** 컨테이너가 비정상적으로 종료되면 자동으로 재시작하거나, 새로운 컨테이너를 생성해 장애를 복구하는 기능을 제공합니다.

## 2. 오케스트레이션의 필요성

현대의 마이크로서비스 아키텍처에서는 수많은 독립적인 컨테이너가 상호작용하면서 애플리케이션을 구성합니다. 이를 수동으로 관리하는 것은 다음과 같은 문제점들을 야기합니다.

- **수동 관리의 복잡성:**  
  수십, 수백 개의 컨테이너를 직접 모니터링하고, 장애 대응, 배포, 스케일링 작업을 수동으로 처리하면 오류 가능성이 높아지고 운영 비용이 증가합니다.
- **효율성 저하:**  
  트래픽 변화나 리소스 수요 변화에 실시간으로 대응하기 어렵고, 서비스 중단이나 성능 저하가 발생할 수 있습니다.
- **운영 리스크 증가:**  
  컨테이너 간 의존성 관리, 자원 할당의 불균형, 장애 발생 시 복구 시간이 길어져 전체 시스템 안정성이 떨어질 수 있습니다.

**오케스트레이션 도구(예: 쿠버네티스)는**

- 시스템의 상태를 지속적으로 감시하여 문제가 발생하면 자동으로 재시작 및 재배포를 수행합니다.
- 애플리케이션의 정의된 상태(Desired State)를 유지하기 위해 노드와 컨테이너 간의 자원 할당을 최적화합니다.
- 서비스 디스커버리, 로드 밸런싱, 네트워크 정책 등을 통합 관리함으로써 운영 전반의 복잡성을 줄여줍니다.

## 3. 쿠버네티스의 역할과 필요성

쿠버네티스는 이러한 오케스트레이션 요구를 충족시키기 위해 설계된 오픈 소스 플랫폼입니다.

- **자동화된 배포 및 확장:**  
  사용자가 YAML 파일 등으로 애플리케이션의 상태를 정의하면, 쿠버네티스는 그 상태를 유지하기 위해 필요한 컨테이너를 생성, 스케일링, 업데이트하며 장애가 발생한 경우 자동 복구를 수행합니다.
- **서비스 디스커버리 및 로드 밸런싱:**  
  컨테이너의 IP 주소가 동적으로 할당되는 문제를 해결하기 위해, 쿠버네티스는 고정된 엔드포인트(서비스)를 제공하고, 클러스터 내부 및 외부 트래픽을 균등하게 분산시켜 줍니다.
- **자원 관리 및 모니터링:**  
  노드와 클러스터 전반의 리소스 사용 상황을 실시간으로 모니터링하며, CPU와 메모리 같은 자원의 효율적인 분배를 통해 시스템 안정성을 유지합니다.
- **이식성 및 확장성 보장:**  
  온프레미스, 퍼블릭 클라우드, 하이브리드 클라우드 등 다양한 환경에서 동일한 방식으로 애플리케이션을 운영할 수 있어, 인프라 변경이나 확장이 필요할 때 유연하게 대응할 수 있습니다.

## 4. 쿠버네티스 아키텍처 개요

쿠버네티스는 **제어 플레인(마스터)**과 **워커 노드**로 구성되어 있으며, 각각의 구성 요소는 특정 역할을 수행합니다.

### 마스터(제어 플레인)

- **API 서버:**  
  클러스터와 외부 간의 유일한 접점입니다. 모든 요청은 API 서버를 통해 전달되며, 인증, 권한 부여, 요청 검증 등의 작업을 수행합니다.
- **컨트롤러 매니저:**  
  여러 컨트롤러(예: 복제 컨트롤러, 엔드포인트 컨트롤러 등)를 실행하여 클러스터의 현재 상태와 원하는 상태 간의 차이를 해소합니다. 이를 통해 자동 복구 및 업데이트가 이루어집니다.
- **스케줄러:**  
  새로운 Pod가 생성되면, 해당 Pod가 실행될 적절한 노드를 선택하여 배치합니다. 노드의 자원 상황, 정책, 태그 등 여러 요소를 고려해 최적의 스케줄링을 수행합니다.
- **etcd:**  
  클러스터 전체의 상태 정보(설정, 상태 데이터 등)를 저장하는 분산 키-값 저장소입니다. 안정성과 신뢰성이 중요한 데이터베이스 역할을 수행합니다.

### 노드 (워커 노드)

- **컨테이너 런타임:**  
  실제 컨테이너를 실행하는 소프트웨어로, Docker, containerd 등이 대표적입니다. 컨테이너를 생성, 실행, 중지하는 역할을 합니다.
- **kubelet:**  
  각 노드에서 실행되며, 마스터와 지속적으로 통신하면서 노드의 상태를 보고하고, 지정된 Pod들이 정상적으로 실행되고 있는지 확인합니다.
- **kube-proxy:**  
  네트워크 프록시 역할을 하며, 클러스터 내에서 서비스 간의 통신을 지원합니다. 로드 밸런싱과 네트워크 트래픽 관리를 통해 Pod에 대한 안정적인 접근을 보장합니다.

### Pod

- **정의 및 특징:**  
  쿠버네티스에서 배포 가능한 가장 작은 단위로, 하나 이상의 컨테이너를 포함합니다. Pod 내의 컨테이너는 동일한 네트워크 네임스페이스를 공유하여, 서로 간의 통신이 빠르고 효율적입니다. 또한, 같은 스토리지 볼륨을 공유함으로써 데이터를 함께 관리할 수 있습니다.
- **사용 사례:**  
  단일 애플리케이션 또는 연관된 여러 프로세스를 한 그룹으로 묶어 실행할 때 유용합니다. Pod는 일시적이며, 필요에 따라 쉽게 생성되고 소멸됩니다.

### Service

- **개념:**  
  Pod 집합에 대한 고정된 네트워크 엔드포인트를 제공하여, 클라이언트가 동적으로 생성되는 Pod에 안정적으로 접근할 수 있도록 합니다.
- **주요 기능:**
  - **로드 밸런싱:**  
    여러 Pod로 트래픽을 분산시켜, 부하를 균등하게 분산합니다.
  - **서비스 디스커버리:**  
    내부 DNS 및 고정 IP를 제공하여, Pod가 재배포되더라도 클라이언트가 동일한 방식으로 접근할 수 있게 합니다.
  - **유형:**  
    ClusterIP(클러스터 내부 전용), NodePort(노드의 특정 포트를 통해 외부 접근), LoadBalancer(외부 로드 밸런서를 활용) 등 다양한 방식으로 서비스를 제공할 수 있습니다.
