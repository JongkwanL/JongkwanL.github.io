---
title: Denormalization
description: >
author: Jongkwan Lee
date: 2025-01-15 20:00:00 +0900
categories: [DB]
tags: [Denormalization]
pin: false
math: true

---
## 개요
데이터베이스 설계 시, 일반적으로 **정규화**(Normalization)를 통해 데이터의 **중복**과 **이상 현상(Anomaly)** 을 최소화하고, 무결성을 높이는 방식을 권장합니다. 그러나 비즈니스 요구사항에 따라 **데이터 액세스 성능을 높이기 위해** 때로는 **반정규화(Denormalization)** 기법을 활용하기도 합니다. 반정규화는 **설계 단계**에서 완전한 정규화를 일부러 깨뜨리고, **중복 데이터를 허용**함으로써 읽기 성능(조회 성능)을 개선하거나 특정 작업을 용이하게 하는 방법입니다.


## 반정규화의 필요성
1. **성능 개선**  
   - 애플리케이션이나 BI 보고서에서 **JOIN이 너무 많아** 복잡해지거나, 응답 시간이 길어지는 문제를 해결할 수 있습니다.  
   - 자주 참조되는 필드를 **중복**해 둠으로써, 단일 테이블 액세스만으로 필요한 정보를 빠르게 조회합니다.

2. **개발 단순화**  
   - 복잡한 다중 조인을 간소화함으로써 SQL을 단순화하거나, 애플리케이션 로직을 간결하게 만들 수 있습니다.

3. **특정 비즈니스 로직**  
   - 단일 쿼리(또는 분석 도구)에서 여러 테이블을 반복 조인해야 하는 경우가 많은 OLAP(온라인 분석 처리) 환경에서, 반정규화를 통해 분석에 소요되는 시간을 단축할 수 있습니다.  
   - 실시간 대시보드나 보고서 생성을 위해 **머티리얼라이즈드 뷰**(Materialized View)를 구성하는 것도 일종의 반정규화입니다.

---

## 반정규화의 단점과 주의사항
1. **데이터 무결성 저하 가능성**  
   - 데이터를 여러 위치에 중복 저장하면, 갱신 시 **불일치(Inconsistency)** 가 발생할 위험이 커집니다.  
   - 모든 중복 컬럼이 동일하게 업데이트되지 않으면, 서로 다른 값을 갖게 되어 데이터 신뢰도가 떨어집니다.

2. **데이터 변경 비용 증가**  
   - 반정규화로 인해 테이블에 **중복된 속성**들이 많으면, INSERT/UPDATE/DELETE 시 더 많은 테이블(또는 컬럼)을 수정해야 합니다.  
   - 이는 쓰기 성능에 부담을 주고, 트랜잭션 충돌 가능성을 높일 수 있습니다.

3. **데이터 구조 복잡도 증가**  
   - 정규화된 구조보다 **관계**가 얽혀 있기 때문에, 어디서 어떻게 중복을 유지하는지 알기가 어려워집니다.  
   - 일정 시간이 지나면, 설계자가 아니면 구조를 이해하기가 어려워질 수 있어 유지보수가 힘들어질 수 있습니다.

4. **사용 사례별 맞춤 설계 필요**  
   - 무조건 반정규화를 진행하는 것은 옳지 않습니다. 읽기/쓰기 패턴, 쿼리 빈도, 데이터 양 등을 종합적으로 분석한 뒤, **명확한 근거**가 있을 때만 수행해야 합니다.

---

## 반정규화 기법의 예시

1. **중복 속성(컬럼) 추가**  
   - 예: 주문 테이블(orders)과 고객 테이블(customers)이 분리되어 있는데, 주문 조회 시 고객 이름만 필요하다면, 주문 테이블에 `customer_name` 컬럼을 추가(중복)해 조회 성능 개선.
   - 장점: JOIN 없이 주문 테이블에서 바로 고객 이름을 확인 가능  
   - 단점: 고객 이름이 변경될 경우, orders 테이블의 `customer_name`도 함께 수정 필요

2. **집계 결과 저장**  
   - 예: 로그 테이블에서 특정 기준(일별, 제품별)의 **합계, 평균, 최대값** 등을 미리 계산해 저장해두는 집계 테이블(또는 컬럼)을 만든다.
   - 장점: 대량의 로그 데이터를 실시간으로 집계할 필요 없이, **미리 계산된 결과**를 빠르게 조회 가능  
   - 단점: 로그가 업데이트되거나 추가될 때마다 집계 테이블도 갱신해주어야 함

3. **머티리얼라이즈드 뷰(Materialized View)**  
   - 복잡한 SELECT 쿼리 결과를 물리적으로 테이블 형태로 저장해둔다.  
   - 장점: 조인, 그룹핑, 정렬이 이미 수행된 결과를 즉시 이용 -> 조회 성능 극대화  
   - 단점: 뷰를 **REFRESH**(갱신)하는 오버헤드가 있음

4. **중복 테이블(테이블 복제)**  
   - 예: 자주 쓰이는 참조 데이터(코드 테이블 등)를 여러 DB 또는 샤드(Shard)에 **복제**해서, 지역/로컬 DB에서 즉시 접근  
   - 장점: 네트워크 트래픽 감소, 지연(Latency) 개선  
   - 단점: 여러 DB에 복제된 데이터 동기화를 위한 복잡한 메커니즘 필요

5. **일부 정규화 단계 해제**  
   - 예: BCNF(보이스-코드 정규형)까지 정규화했던 테이블을 3NF(제3정규형)나 2NF 수준으로 의도적으로 낮춰서, 한 테이블에 더 많은 속성을 담아 **조인 횟수**를 줄이는 방법  
   - 장점: 조인 비중을 줄여, 조회 성능 향상  
   - 단점: 데이터 중복도 역시 상승 가능

---

## 반정규화 적용 시 고려사항

1. **접근 패턴(읽기 vs 쓰기 비중)**  
   - 반정규화는 **읽기 비중이 매우 높고, 쓰기 비중이 낮은** 환경에 적합합니다.  
   - 예: 읽기가 99%, 쓰기가 1% 정도인 데이터 웨어하우스(OLAP)나 BI 시스템에서 유리

2. **명확한 성능 개선 목표 설정**  
   - 반정규화를 통해 **쿼리 응답 시간이 어느 정도** 단축될 것인지, 수치화/측정 가능한 목표가 있어야 합니다.  
   - 충분한 벤치마크(Performance Test)와 함께 진행해야 하며, 무조건적인 반정규화는 피해야 합니다.

3. **데이터 동기화 전략**  
   - 중복된 데이터가 변경될 때 어떻게 동기화할지(트리거, 배치 작업, 애플리케이션 로직 등)를 미리 설계해야 합니다.

4. **장기적인 유지보수 비용**  
   - 반정규화를 하면 설계가 복잡해지므로, 향후 요구사항 변경, 시스템 확장 시 발생할 수 있는 **유지보수 비용**을 고려해야 합니다.

---

## 정리
반정규화(Denormalization)는 **데이터 무결성(정합성)을 약간 희생**하는 대신, **읽기 성능 및 쿼리 단순화**를 얻는 **설계 기법**입니다.  
- **OLAP, BI, 데이터 마트** 등에서 **조회가 매우 잦은** 환경에서 큰 효과를 발휘합니다.  
- 반면 **실시간 트랜잭션(OLTP)** 처리가 빈번한 시스템에서는 쓰기 비용 증가와 데이터 불일치를 야기할 수 있으므로 신중히 접근해야 합니다.  
- 반정규화를 결정하기 전에, **실행 계획(Explain Plan), 인덱스, 캐싱, 쿼리 최적화** 등 다른 성능 개선 방안을 먼저 고려하고, 그럼에도 이점이 충분히 클 때 적용하는 것이 일반적입니다.

결론적으로 **반정규화는 고성능을 추구하는 실무 환경에서 자주 활용되지만**, 그만큼 **데이터 무결성을 관리하기 위한 체계적인 전략(트리거, 스크립트, 프로시저, 배치 등)**이 필수적입니다. 상황에 맞는 균형 잡힌 데이터 모델링을 통해, **정규화와 반정규화**를 적절히 활용하는 것이 중요합니다.