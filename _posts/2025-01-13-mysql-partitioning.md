---
title: Django Custom pagination
description: >
author: Jongkwan Lee
date: 2025-01-13 21:00:00 +0900
categories: [MySQL]
tags: [MySQL, Partitioning]
pin: false
math: true

media_subpath: '/posts/20250112'
---
### MySQL의 파티셔닝(Partitioning)

**파티셔닝**은 데이터베이스 테이블을 여러 작은 부분으로 나누어 데이터를 효율적으로 관리하고 성능을 개선하는 기법

MySQL에서 파티셔닝은 대용량 테이블의 성능을 최적화하기 위한 중요한 방법 중 하나

테이블이 너무 커질 경우, 데이터 접근 속도가 느려질 수 있으며, 파티셔닝을 통해 테이블을 물리적으로 나누어 쿼리 성능을 향상시킬 수 있습니다.

파티셔닝을 적용하면 MySQL은 쿼리 실행 시 전체 테이블을 탐색하는 것이 아니라, 필요한 파티션만을 검색하여 성능을 높일 수 있습니다. 다양한 파티셔닝 방식은 데이터의 성격에 맞게 선택할 수 있으며, 각각의 방식은 특정 사용 사례에 적합합니다.

---

### 1. **파티셔닝의 주요 이점**

- **성능 향상**: 테이블의 특정 파티션만을 읽거나 쓰도록 하여 검색 속도를 향상시킬 수 있습니다. 특히 대용량 테이블에서 자주 사용되는 쿼리에서 성능 개선을 기대할 수 있습니다.
- **관리 용이성**: 파티션 단위로 백업, 복구, 또는 아카이빙을 수행할 수 있으므로 대규모 데이터를 관리하기 용이합니다.
- **병렬 처리**: 일부 데이터베이스 작업에서 각 파티션을 독립적으로 처리할 수 있어 병렬 작업의 이점을 누릴 수 있습니다.

---

### 2. **MySQL에서 지원하는 파티셔닝 방식**

MySQL에서는 여러 유형의 파티셔닝을 지원하며, 각 유형은 데이터 분할 방식에 따라 다릅니다.

### 1. **Range Partitioning (범위 파티셔닝)**

- **개념**: 범위 파티셔닝은 특정 범위에 따라 데이터를 분할하는 방식입니다. 일반적으로 날짜, 숫자, ID 등의 연속적인 값으로 데이터를 나눌 때 사용됩니다. 예를 들어, 연도나 월을 기준으로 데이터를 파티셔닝할 수 있습니다.
- **사용 예시**:
    
    ```sql
    CREATE TABLE orders (
      order_id INT,
      order_date DATE,
      customer_id INT,
      amount DECIMAL(10, 2)
    )
    PARTITION BY RANGE (YEAR(order_date)) (
      PARTITION p0 VALUES LESS THAN (2021),
      PARTITION p1 VALUES LESS THAN (2022),
      PARTITION p2 VALUES LESS THAN (2023),
      PARTITION p3 VALUES LESS THAN (2024)
    );
    
    ```
    
- **장점**: 쿼리에서 특정 범위를 자주 조회할 때, 해당 범위에 속하는 데이터만을 파티션에서 조회하여 성능을 크게 향상시킬 수 있습니다.
- **단점**: 데이터의 분포가 고르지 않으면 특정 파티션에 데이터가 몰릴 수 있습니다.

### 2. **List Partitioning (목록 파티셔닝)**

- **개념**: 목록 파티셔닝은 **지정된 값 목록**에 따라 데이터를 분할하는 방식입니다. 특정 값을 기준으로 데이터를 논리적으로 나누는 데 유용합니다. 국가 코드, 지역, 상태 값 등 명확히 나눌 수 있는 값을 기준으로 나눌 때 자주 사용됩니다.
- **사용 예시**:
    
    ```sql
    CREATE TABLE customers (
      customer_id INT,
      customer_name VARCHAR(50),
      country_code CHAR(2)
    )
    PARTITION BY LIST (country_code) (
      PARTITION p_us VALUES IN ('US'),
      PARTITION p_uk VALUES IN ('UK'),
      PARTITION p_ca VALUES IN ('CA')
    );
    
    ```
    
- **장점**: 특정 카테고리나 값에 따라 데이터를 나눌 때 적합하며, 쿼리가 목록 값에 따라 최적화될 수 있습니다.
- **단점**: 목록에 정의되지 않은 값은 추가 파티션을 만들어야 하며, 값의 범위가 넓을 경우 비효율적일 수 있습니다.

### 3. **Hash Partitioning (해시 파티셔닝)**

- **개념**: 해시 파티셔닝은 **해시 함수**를 사용하여 데이터를 균등하게 분할합니다. 해시 함수는 특정 컬럼 값을 입력으로 받아 결과 값에 따라 데이터를 분할하므로, 데이터가 특정 패턴 없이 균등하게 분산될 수 있습니다.
- **사용 예시**:
    
    ```sql
    CREATE TABLE transactions (
      transaction_id INT,
      customer_id INT,
      amount DECIMAL(10, 2)
    )
    PARTITION BY HASH (customer_id) PARTITIONS 4;
    
    ```
    
- **장점**: 데이터를 균등하게 분산할 수 있어 특정 파티션에 데이터가 몰리는 현상을 방지합니다. 특히 고르게 분포된 데이터를 다룰 때 매우 유용합니다.
- **단점**: 해시 함수의 특성상 범위 쿼리에 대한 최적화가 어렵고, 특정 패턴의 데이터를 효율적으로 분할하지 못할 수 있습니다.

### 4. **Key Partitioning (키 파티셔닝)**

- **개념**: 해시 파티셔닝과 유사하지만, 해시 함수를 사용하지 않고, 프라이머리 키나 유니크 키와 같은 컬럼을 기준으로 데이터를 자동으로 분할하는 방식입니다. MySQL의 내부 해시 알고리즘을 사용하여 데이터를 파티셔닝합니다.
- **사용 예시**:
    
    ```sql
    CREATE TABLE logs (
      log_id INT AUTO_INCREMENT,
      log_message VARCHAR(255)
    )
    PARTITION BY KEY(log_id) PARTITIONS 4;
    
    ```
    
- **장점**: 키 파티셔닝은 기본적으로 프라이머리 키나 유니크 키를 사용하므로, 인덱스와 파티셔닝이 자연스럽게 결합되어 효율적입니다. 또한, 사용자가 해시 함수를 명시하지 않아도 MySQL이 자동으로 최적화된 해시를 사용합니다.
- **단점**: 해시 파티셔닝과 마찬가지로 범위 쿼리에는 적합하지 않습니다.

---

### 3. **파티셔닝의 주요 관리 작업**

파티셔닝된 테이블은 기본적으로 여러 개의 논리적 테이블로 나뉘기 때문에, 이를 효과적으로 관리하고 성능을 유지하기 위한 추가적인 작업들이 필요합니다.

### 1. **파티션 추가 및 삭제**

- 데이터를 처리하는 중에 새로운 범위나 값이 필요할 때 파티션을 동적으로 추가할 수 있습니다.
- 예시:
    
    ```sql
    ALTER TABLE orders ADD PARTITION (
      PARTITION p4 VALUES LESS THAN (2024)
    );
    
    ```
    
- 마찬가지로, 더 이상 필요하지 않은 파티션은 삭제할 수 있습니다.
- 예시:
    
    ```sql
    ALTER TABLE orders DROP PARTITION p0;
    
    ```
    

### 2. **파티션 병합 및 분할**

- 데이터를 효율적으로 관리하기 위해 파티션을 병합하거나, 반대로 큰 파티션을 여러 개로 나눌 수 있습니다. MySQL에서 파티션 병합은 명시적으로 지원되지 않지만, 데이터를 적절히 마이그레이션하여 수행할 수 있습니다.

### 3. **파티션 유지 보수**

- 특정 파티션에 대해 데이터 백업, 아카이빙, 삭제 작업 등을 수행할 수 있습니다. 이는 대량 데이터를 다루는 경우 관리 작업을 쉽게 만들어 줍니다.

---

### 4. **파티셔닝 최적화 및 유의 사항**

- **쿼리 최적화**: 파티셔닝된 테이블에서 쿼리할 때 MySQL이 모든 파티션을 스캔하지 않도록, 파티션 프루닝(partition pruning)이 가능하게 쿼리를 설계해야 합니다. 이는 MySQL이 필요한 파티션만을 검색하도록 쿼리를 제한하는 작업입니다. 예를 들어, `WHERE` 조건에서 파티셔닝 컬럼을 포함시키는 것이 좋습니다.
- **적합한 파티셔닝 전략 선택**: 모든 테이블이 파티셔닝에 적합한 것은 아닙니다. 특히, 작은 테이블에서는 파티셔닝의 이점이 거의 없으며, 오히려 관리 복잡성만 증가할 수 있습니다. 파티셔닝이 필요한 테이블은 보통 수백만 이상의 행을 가진 대용량 테이블입니다.
- **인덱스와 파티셔닝의 조화**: 파티셔닝된 테이블에 인덱스를 추가하면 MySQL이 효율적으로 데이터를 검색할 수 있습니다. 하지만 모든 파티션에 인덱스를 따로 관리해야 하므로 성능에 유의해야 합니다.

---

### 5. **파티셔닝의 한계**

- **복잡성 증가**: 파티셔닝은 성능 최적화에 도움을 줄 수 있지만, 설계와 관리의 복잡성을 추가합니다. 특히, 잘못된 파티셔닝 전략은 성능을 저하시킬 수 있습니다.

- **제약 조건**: 일부 제약 조건(`FOREIGN KEY` 등)은 파티셔닝된 테이블에서 지원되지 않을 수 있습니다.
- **데이터 이동의 오버헤드**: 파티션 간 데이터를 이동하거나 병합할 때 성능 오버헤드가 발생할 수 있습니다.

---

데이터의 특성과 쿼리 패턴에 맞게 적절한 파티셔닝 방식을 선택